#include "ast.h"
#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include <string.h>

// 全局变量
static int data_section_initialized = 0;
static int string_label = 0;
static int float_label = 0;
static int label_count = 0;
static int stack_offset = 4;

// 变量符号表结构
typedef struct
{
    char *name;
    int offset;
} Variable;

static Variable *variables = NULL;
static int variable_count = 0;
static int variable_capacity = 0;

// 查找变量偏移量
static int get_variable_offset(const char *name)
{
    for (int i = 0; i < variable_count; i++)
    {
        if (strcmp(variables[i].name, name) == 0)
        {
            return variables[i].offset;
        }
    }
    return -1;
}

// 添加新变量
static int add_variable(const char *name)
{
    int offset = get_variable_offset(name);
    if (offset != -1)
    {
        return offset;
    }

    if (variable_count >= variable_capacity)
    {
        variable_capacity = variable_capacity == 0 ? 8 : variable_capacity * 2;
        variables = realloc(variables, variable_capacity * sizeof(Variable));
    }

    variables[variable_count].name = strdup(name);
    variables[variable_count].offset = stack_offset;
    stack_offset += 4;
    return variables[variable_count++].offset;
}

// 清理变量表
static void clear_variables()
{
    for (int i = 0; i < variable_count; i++)
    {
        free(variables[i].name);
    }
    free(variables);
    variables = NULL;
    variable_count = 0;
    variable_capacity = 0;
    stack_offset = 4;
}

// AST节点创建函数
ASTNode *ast_new_integer(int value, int line_no)
{
    ASTNode *node = malloc(sizeof(ASTNode));
    node->type = AST_INTEGER;
    node->line_no = line_no;
    node->int_value = value;
    return node;
}

ASTNode *ast_new_float(float value, int line_no)
{
    ASTNode *node = malloc(sizeof(ASTNode));
    node->type = AST_FLOAT;
    node->line_no = line_no;
    node->float_value = value;
    return node;
}

ASTNode *ast_new_string(char *value, int line_no)
{
    ASTNode *node = malloc(sizeof(ASTNode));
    node->type = AST_STRING;
    node->line_no = line_no;
    node->string_value = strdup(value);
    return node;
}

ASTNode *ast_new_variable(char *name, int line_no)
{
    ASTNode *node = malloc(sizeof(ASTNode));
    node->type = AST_VARIABLE;
    node->line_no = line_no;
    node->string_value = strdup(name);
    return node;
}

ASTNode *ast_new_function_def(char *func_name, char *return_type, ASTNode *param_block,
                              ASTNode *body, int line_no)
{
    ASTNode *node = malloc(sizeof(ASTNode));
    if (node == NULL)
    {
        fprintf(stderr, "Error: Memory allocation failed for function definition\n");
        exit(1);
    }

    node->type = AST_FUNCTION_DEF;
    node->line_no = line_no;
    node->func_def.func_name = strdup(func_name);
    node->func_def.return_type = strdup(return_type);

    if (param_block && param_block->type == AST_BLOCK)
    {
        node->func_def.params = param_block->block.statements;
        node->func_def.param_count = param_block->block.count;
        free(param_block);
    }
    else
    {
        node->func_def.params = NULL;
        node->func_def.param_count = 0;
    }

    node->func_def.body = body;
    return node;
}

ASTNode *ast_new_formatted_print(char *format_string, ASTNode **args,
                                 int arg_count, int line_no)
{
    ASTNode *node = malloc(sizeof(ASTNode));
    node->type = AST_FORMATTED_PRINT;
    node->line_no = line_no;
    node->formatted_print.format_string = strdup(format_string);
    node->formatted_print.args = args;
    node->formatted_print.arg_count = arg_count;
    return node;
}

ASTNode *ast_new_array_declaration(char *var_name, ASTNode *size, int line_no)
{
    ASTNode *node = malloc(sizeof(ASTNode));
    node->type = AST_ARRAY_DECLARATION;
    node->line_no = line_no;
    node->array_decl.var_name = strdup(var_name);
    node->array_decl.size = size;
    return node;
}

ASTNode *ast_new_array_access(char *var_name, ASTNode *index, int line_no)
{
    ASTNode *node = malloc(sizeof(ASTNode));
    node->type = AST_ARRAY_ACCESS;
    node->line_no = line_no;
    node->array_access.var_name = strdup(var_name);
    node->array_access.index = index;
    return node;
}

ASTNode *ast_new_array_assignment(ASTNode *array_access, ASTNode *value, int line_no)
{
    ASTNode *node = malloc(sizeof(ASTNode));
    node->type = AST_ARRAY_ASSIGNMENT;
    node->line_no = line_no;
    node->array_assignment.array_access = array_access;
    node->array_assignment.value = value;
    return node;
}

ASTNode *ast_new_binary_op(char *op, ASTNode *left, ASTNode *right, int line_no)
{
    ASTNode *node = malloc(sizeof(ASTNode));
    node->type = AST_BINARY_OP;
    node->line_no = line_no;
    node->binary.op = strdup(op);
    node->binary.left = left;
    node->binary.right = right;
    return node;
}

ASTNode *ast_new_assignment(ASTNode *var, ASTNode *expr, int line_no)
{
    ASTNode *node = malloc(sizeof(ASTNode));
    node->type = AST_ASSIGNMENT;
    node->line_no = line_no;
    node->binary.left = var;
    node->binary.right = expr;
    return node;
}

ASTNode *ast_new_if(ASTNode *cond, ASTNode *then_body, ASTNode *else_body, int line_no)
{
    ASTNode *node = malloc(sizeof(ASTNode));
    node->type = AST_IF;
    node->line_no = line_no;
    node->if_stmt.cond = cond;
    node->if_stmt.then_body = then_body;
    node->if_stmt.else_body = else_body;
    return node;
}

ASTNode *ast_new_while(ASTNode *cond, ASTNode *body, int line_no)
{
    ASTNode *node = malloc(sizeof(ASTNode));
    node->type = AST_WHILE;
    node->line_no = line_no;
    node->while_loop.cond = cond;
    node->while_loop.body = body;
    return node;
}

ASTNode *ast_new_for(ASTNode *init, ASTNode *cond, ASTNode *update, ASTNode *body, int line_no)
{
    ASTNode *node = malloc(sizeof(ASTNode));
    node->type = AST_FOR;
    node->line_no = line_no;
    node->for_loop.init = init;
    node->for_loop.cond = cond;
    node->for_loop.update = update;
    node->for_loop.body = body;
    return node;
}

ASTNode *ast_new_block(ASTNode **statements, int count, int line_no)
{
    ASTNode *node = malloc(sizeof(ASTNode));
    node->type = AST_BLOCK;
    node->line_no = line_no;
    node->block.statements = statements;
    node->block.count = count;
    return node;
}

ASTNode *ast_new_declaration(char *var_name, int line_no)
{
    ASTNode *node = malloc(sizeof(ASTNode));
    node->type = AST_DECLARATION;
    node->line_no = line_no;
    node->decl.var_name = strdup(var_name);
    node->decl.init_value = NULL;
    return node;
}

ASTNode *ast_new_param_declaration(char *var_name, char *var_type, int line_no)
{
    ASTNode *node = malloc(sizeof(ASTNode));
    node->type = AST_PARAM_DECLARATION;
    node->line_no = line_no;
    node->decl.var_name = strdup(var_name);
    node->decl.var_type = strdup(var_type);
    node->decl.init_value = NULL;
    return node;
}

ASTNode *ast_new_declaration_init(char *var_name, ASTNode *init_value, int line_no)
{
    ASTNode *node = malloc(sizeof(ASTNode));
    node->type = AST_DECLARATION_INIT;
    node->line_no = line_no;
    node->decl.var_name = strdup(var_name);
    node->decl.init_value = init_value;
    return node;
}

ASTNode *ast_new_function_call(char *func_name, ASTNode **args, int arg_count, int line_no)
{
    if (func_name == NULL)
    {
        fprintf(stderr, "Error: NULL function name\n");
        exit(1);
    }

    ASTNode *node = malloc(sizeof(ASTNode));
    if (node == NULL)
    {
        fprintf(stderr, "Error: Memory allocation failed\n");
        exit(1);
    }

    memset(node, 0, sizeof(ASTNode));

    node->type = AST_FUNCTION_CALL;
    node->line_no = line_no;
    node->func_call.func_name = strdup(func_name);
    if (node->func_call.func_name == NULL)
    {
        fprintf(stderr, "Error: Memory allocation failed\n");
        free(node);
        exit(1);
    }

    if (arg_count > 0)
    {
        node->func_call.args = malloc(sizeof(ASTNode *) * arg_count);
        if (node->func_call.args == NULL)
        {
            fprintf(stderr, "Error: Memory allocation failed\n");
            free(node->func_call.func_name);
            free(node);
            exit(1);
        }

        for (int i = 0; i < arg_count; i++)
        {
            node->func_call.args[i] = args[i];
        }
    }
    else
    {
        node->func_call.args = NULL;
    }

    node->func_call.arg_count = arg_count;
    return node;
}

ASTNode *ast_new_return(ASTNode *expr, int line_no)
{
    ASTNode *node = malloc(sizeof(ASTNode));
    node->type = AST_RETURN;
    node->line_no = line_no;
    node->binary.left = expr;
    return node;
}

ASTNode *ast_new_empty(int line_no)
{
    ASTNode *node = malloc(sizeof(ASTNode));
    node->type = AST_EMPTY;
    node->line_no = line_no;
    return node;
}

// AST打印和释放函数
void ast_print_indent(int indent)
{
    for (int i = 0; i < indent; i++)
    {
        printf("  ");
    }
}

void ast_print(ASTNode *node, int indent)
{
    if (!node)
        return;

    ast_print_indent(indent);
    printf("Line %d: ", node->line_no);

    switch (node->type)
    {
    case AST_INTEGER:
        printf("INTEGER(%d)\n", node->int_value);
        break;
    case AST_FLOAT:
        printf("FLOAT(%f)\n", node->float_value);
        break;
    case AST_STRING:
        printf("STRING(\"%s\")\n", node->string_value);
        break;
    case AST_VARIABLE:
        printf("VARIABLE(%s)\n", node->string_value);
        break;
    case AST_FUNCTION_DEF:
        printf("FUNCTION_DEF(%s, returns: %s)\n",
               node->func_def.func_name, node->func_def.return_type);
        for (int i = 0; i < node->func_def.param_count; i++)
        {
            ast_print(node->func_def.params[i], indent + 1);
        }
        ast_print(node->func_def.body, indent + 1);
        break;
    case AST_FORMATTED_PRINT:
        printf("FORMATTED_PRINT(\"%s\")\n", node->formatted_print.format_string);
        for (int i = 0; i < node->formatted_print.arg_count; i++)
        {
            ast_print(node->formatted_print.args[i], indent + 1);
        }
        break;
    case AST_PARAM_DECLARATION:
        printf("PARAM_DECLARATION(%s: %s)\n", node->decl.var_name, node->decl.var_type);
        break;
    case AST_ARRAY_DECLARATION:
        printf("ARRAY_DECLARATION(%s", node->array_decl.var_name);
        if (node->array_decl.size)
        {
            printf("[");
            ast_print(node->array_decl.size, 0);
            printf("]");
        }
        printf(")\n");
        break;
    case AST_ARRAY_ACCESS:
        printf("ARRAY_ACCESS(%s[", node->array_access.var_name);
        ast_print(node->array_access.index, 0);
        printf("])\n");
        break;
    case AST_ARRAY_ASSIGNMENT:
        printf("ARRAY_ASSIGNMENT\n");
        ast_print(node->array_assignment.array_access, indent + 1);
        ast_print(node->array_assignment.value, indent + 1);
        break;
    case AST_BINARY_OP:
        printf("BINARY_OP(%s)\n", node->binary.op);
        ast_print(node->binary.left, indent + 1);
        ast_print(node->binary.right, indent + 1);
        break;
    case AST_ASSIGNMENT:
        printf("ASSIGNMENT\n");
        ast_print(node->binary.left, indent + 1);
        ast_print(node->binary.right, indent + 1);
        break;
    case AST_IF:
        printf("IF\n");
        ast_print(node->if_stmt.cond, indent + 1);
        ast_print(node->if_stmt.then_body, indent + 1);
        if (node->if_stmt.else_body)
        {
            ast_print(node->if_stmt.else_body, indent + 1);
        }
        break;
    case AST_WHILE:
        printf("WHILE\n");
        ast_print(node->while_loop.cond, indent + 1);
        ast_print(node->while_loop.body, indent + 1);
        break;
    case AST_FOR:
        printf("FOR\n");
        ast_print(node->for_loop.init, indent + 1);
        ast_print(node->for_loop.cond, indent + 1);
        ast_print(node->for_loop.update, indent + 1);
        ast_print(node->for_loop.body, indent + 1);
        break;
    case AST_BLOCK:
        printf("BLOCK (%d statements)\n", node->block.count);
        for (int i = 0; i < node->block.count; i++)
        {
            ast_print(node->block.statements[i], indent + 1);
        }
        break;
    case AST_DECLARATION:
        printf("DECLARATION(%s)\n", node->decl.var_name);
        break;
    case AST_DECLARATION_INIT:
        printf("DECLARATION_INIT(%s)\n", node->decl.var_name);
        ast_print(node->decl.init_value, indent + 1);
        break;
    case AST_FUNCTION_CALL:
        printf("FUNCTION_CALL(%s)\n", node->func_call.func_name);
        if (node->func_call.args != NULL)
        {
            for (int i = 0; i < node->func_call.arg_count; i++)
            {
                if (node->func_call.args[i] != NULL)
                {
                    ast_print(node->func_call.args[i], indent + 1);
                }
            }
        }
        break;
    case AST_RETURN:
        printf("RETURN\n");
        ast_print(node->binary.left, indent + 1);
        break;
    case AST_EMPTY:
        printf("EMPTY\n");
        break;
    default:
        printf("UNKNOWN\n");
    }
}

void ast_free(ASTNode *node)
{
    if (!node)
        return;

    switch (node->type)
    {
    case AST_STRING:
        free(node->string_value);
        break;
    case AST_VARIABLE:
        free(node->string_value);
        break;
    case AST_FUNCTION_DEF:
        free(node->func_def.func_name);
        free(node->func_def.return_type);
        for (int i = 0; i < node->func_def.param_count; i++)
        {
            ast_free(node->func_def.params[i]);
        }
        free(node->func_def.params);
        ast_free(node->func_def.body);
        break;
    case AST_FORMATTED_PRINT:
        free(node->formatted_print.format_string);
        for (int i = 0; i < node->formatted_print.arg_count; i++)
        {
            ast_free(node->formatted_print.args[i]);
        }
        free(node->formatted_print.args);
        break;
    case AST_PARAM_DECLARATION:
        free(node->decl.var_name);
        free(node->decl.var_type);
        break;
    case AST_ARRAY_DECLARATION:
        free(node->array_decl.var_name);
        ast_free(node->array_decl.size);
        break;
    case AST_ARRAY_ACCESS:
        free(node->array_access.var_name);
        ast_free(node->array_access.index);
        break;
    case AST_ARRAY_ASSIGNMENT:
        ast_free(node->array_assignment.array_access);
        ast_free(node->array_assignment.value);
        break;
    case AST_BINARY_OP:
        free(node->binary.op);
        ast_free(node->binary.left);
        ast_free(node->binary.right);
        break;
    case AST_ASSIGNMENT:
        ast_free(node->binary.left);
        ast_free(node->binary.right);
        break;
    case AST_IF:
        ast_free(node->if_stmt.cond);
        ast_free(node->if_stmt.then_body);
        ast_free(node->if_stmt.else_body);
        break;
    case AST_WHILE:
        ast_free(node->while_loop.cond);
        ast_free(node->while_loop.body);
        break;
    case AST_FOR:
        ast_free(node->for_loop.init);
        ast_free(node->for_loop.cond);
        ast_free(node->for_loop.update);
        ast_free(node->for_loop.body);
        break;
    case AST_BLOCK:
        for (int i = 0; i < node->block.count; i++)
        {
            ast_free(node->block.statements[i]);
        }
        free(node->block.statements);
        break;
    case AST_DECLARATION:
        free(node->decl.var_name);
        break;
    case AST_DECLARATION_INIT:
        free(node->decl.var_name);
        ast_free(node->decl.init_value);
        break;
    case AST_FUNCTION_CALL:
        if (node->func_call.func_name != NULL)
        {
            free(node->func_call.func_name);
        }
        if (node->func_call.args != NULL)
        {
            for (int i = 0; i < node->func_call.arg_count; i++)
            {
                if (node->func_call.args[i] != NULL)
                {
                    ast_free(node->func_call.args[i]);
                }
            }
            free(node->func_call.args);
        }
        break;
    case AST_RETURN:
        ast_free(node->binary.left);
        break;
    default:
        break;
    }

    free(node);
}

// 汇编代码生成函数
void ast_write_to_file(ASTNode *node, const char *filename)
{
    FILE *output = fopen(filename, "w");
    if (!output)
    {
        fprintf(stderr, "Error: Cannot open file %s\n", filename);
        return;
    }

    clear_variables();
    stack_offset = 4;

    char *basename = strrchr(filename, '/');
    if (!basename)
        basename = strrchr(filename, '\\');
    basename = basename ? basename + 1 : (char *)filename;
    char *dot = strrchr(basename, '.');
    if (dot)
        *dot = '\0';

    fprintf(output, "\t.file\t\"%s.c\"\n", basename);

    // 首先定义错误消息字符串
    fprintf(output, "\t.section .rdata,\"dr\"\n");
    fprintf(output, ".LC0:\n");
    fprintf(output, "\t.ascii \"Runtime error: Array index out of bounds\\0\"\n");

    // 错误处理函数作为全局函数
    fprintf(output, "\t.text\n");
    fprintf(output, "\t.globl\tarray_bounds_error\n");
    fprintf(output, "\t.def\tarray_bounds_error; .scl 2; .type 32; .endef\n");
    fprintf(output, "\t.seh_proc\tarray_bounds_error\n");
    fprintf(output, "array_bounds_error:\n");
    fprintf(output, "\tpushq\t%%rbp\n");
    fprintf(output, "\t.seh_pushreg\t%%rbp\n");
    fprintf(output, "\tmovq\t%%rsp, %%rbp\n");
    fprintf(output, "\t.seh_setframe\t%%rbp, 0\n");
    fprintf(output, "\tsubq\t$32, %%rsp\n");
    fprintf(output, "\t.seh_stackalloc\t32\n");
    fprintf(output, "\t.seh_endprologue\n");
    fprintf(output, "\tleaq\t.LC0(%%rip), %%rcx\n");
    fprintf(output, "\tcall\tprintf\n");
    fprintf(output, "\tmovl\t$1, %%ecx\n");
    fprintf(output, "\tcall\texit\n");
    fprintf(output, "\tnop\n");
    fprintf(output, "\t.seh_endproc\n");
    fprintf(output, "\n");

    // 全局函数声明
    fprintf(output, "\t.globl\tmain\n");
    fprintf(output, "\t.def\t__main;\t.scl\t2;\t.type\t32;\t.endef\n");
    fprintf(output, "\t.def\tprintf;\t.scl\t2;\t.type\t32;\t.endef\n");
    fprintf(output, "\t.def\texit;\t.scl\t2;\t.type\t32;\t.endef\n");

    // main函数开始
    fprintf(output, "\t.seh_proc\tmain\n");
    fprintf(output, "main:\n");
    fprintf(output, "\tpushq\t%%rbp\n");
    fprintf(output, "\tmovq\t%%rsp, %%rbp\n");
    fprintf(output, "\tsubq\t$96, %%rsp\n");
    fprintf(output, "\tcall\t__main\n");

    ast_generate_assembly(node, output);

    fprintf(output, "\tmovl\t$0, %%eax\n");
    fprintf(output, "\taddq\t$96, %%rsp\n");
    fprintf(output, "\tpopq\t%%rbp\n");
    fprintf(output, "\tret\n");
    fprintf(output, "\t.seh_endproc\n");

    fclose(output);
}

void ast_generate_assembly(ASTNode *node, FILE *output)
{
    if (!node)
        return;

    switch (node->type)
    {
    case AST_INTEGER:
        fprintf(output, "\tmovl\t$%d, %%eax\n", node->int_value);
        break;

    case AST_FLOAT:
        fprintf(output, "\t.section .rdata\n");
        fprintf(output, ".LF%d:\n", float_label);
        fprintf(output, "\t.float\t%f\n", node->float_value);
        fprintf(output, "\t.section .text\n");
        fprintf(output, "\tmovss\t.LF%d(%%rip), %%xmm0\n", float_label);
        float_label++;
        break;

    case AST_STRING:
        fprintf(output, "\t.section .rdata\n");
        fprintf(output, ".LS%d:\n", string_label);
        fprintf(output, "\t.ascii\t\"");
        for (int i = 0; node->string_value[i]; i++)
        {
            switch (node->string_value[i])
            {
            case '\n':
                fprintf(output, "\\12");
                break;
            case '\t':
                fprintf(output, "\\11");
                break;
            case '\r':
                fprintf(output, "\\15");
                break;
            case '\\':
                fprintf(output, "\\\\");
                break;
            case '\"':
                fprintf(output, "\\\"");
                break;
            default:
                if (isprint(node->string_value[i]))
                {
                    fputc(node->string_value[i], output);
                }
                break;
            }
        }
        fprintf(output, "\\0\"\n");
        fprintf(output, "\t.section .text\n");
        fprintf(output, "\tleaq\t.LS%d(%%rip), %%rax\n", string_label);
        string_label++;
        break;

    case AST_VARIABLE:
    {
        int var_offset = get_variable_offset(node->string_value);
        if (var_offset == -1)
        {
            fprintf(stderr, "Error: Undefined variable '%s'\n", node->string_value);
            exit(1);
        }
        fprintf(output, "\tmovl\t-%d(%%rbp), %%eax\n", var_offset);
    }
    break;
    case AST_FORMATTED_PRINT:
    {
        int format_label = string_label++;

        fprintf(output, "\t.section .rdata,\"dr\"\n");
        fprintf(output, ".LS%d:\n", format_label);
        fprintf(output, "\t.ascii \"");

        // 格式字符串处理
        for (int i = 0; node->formatted_print.format_string[i]; i++)
        {
            char c = node->formatted_print.format_string[i];
            if (c == '\n')
                fprintf(output, "\\\\n");
            else if (c == '\t')
                fprintf(output, "\\\\t");
            else if (c == '\r')
                fprintf(output, "\\\\r");
            else if (c == '\\')
                fprintf(output, "\\\\\\\\");
            else if (c == '\"')
                fprintf(output, "\\\\\"");
            else if (c == '%')
                fprintf(output, "%%%%");
            else if (isprint(c))
                fputc(c, output);
        }
        fprintf(output, "\\\\0\"\n");
        fprintf(output, "\t.section .text\n");

        // Windows x64调用约定：计算需要的栈空间
        int total_args = node->formatted_print.arg_count;
        int stack_args = (total_args > 4) ? (total_args - 4) : 0;
        int shadow_space = 32; // 前4个参数的shadow space
        int stack_space = shadow_space + (stack_args * 8);

        // 确保16字节对齐
        stack_space = (stack_space + 15) & ~15;

        // 分配栈空间
        fprintf(output, "\tsubq\t$%d, %%rsp\n", stack_space);

        // 处理所有参数
        for (int i = 0; i < total_args; i++)
        {
            ast_generate_assembly(node->formatted_print.args[i], output);

            // 根据参数位置选择寄存器或栈位置
            switch (i)
            {
            case 0: // 第一个参数：格式字符串 -> RCX
                fprintf(output, "\tmovq\t%%rax, %%rcx\n");
                break;
            case 1: // 第二个参数 -> RDX
                fprintf(output, "\tmovl\t%%eax, %%edx\n");
                break;
            case 2: // 第三个参数 -> R8
                fprintf(output, "\tmovl\t%%eax, %%r8d\n");
                break;
            case 3: // 第四个参数 -> R9
                fprintf(output, "\tmovl\t%%eax, %%r9d\n");
                break;
            default: // 其他参数放在栈上
                // 栈参数从shadow space之后开始（32字节偏移）
                int stack_offset = 32 + (i - 4) * 8;
                fprintf(output, "\tmovl\t%%eax, %d(%%rsp)\n", stack_offset);
                break;
            }
        }

        // 对于可变参数函数，设置AL=使用的XMM寄存器数量（这里设为0）
        fprintf(output, "\txor\t%%al, %%al\n");

        // 调用printf
        fprintf(output, "\tcall\tprintf\n");

        // 恢复栈指针
        fprintf(output, "\taddq\t$%d, %%rsp\n", stack_space);
    }
    break;

    case AST_FUNCTION_CALL:
    {
        // Windows x64调用约定
        int total_args = node->func_call.arg_count;
        int stack_args = (total_args > 4) ? (total_args - 4) : 0;
        int shadow_space = 32;
        int stack_space = shadow_space + (stack_args * 8);
        stack_space = (stack_space + 15) & ~15; // 16字节对齐

        fprintf(output, "\tsubq\t$%d, %%rsp\n", stack_space);

        // 处理参数
        for (int i = 0; i < total_args; i++)
        {
            ast_generate_assembly(node->func_call.args[i], output);

            switch (i)
            {
            case 0:
                fprintf(output, "\tmov\t%%eax, %%ecx\n");
                break;
            case 1:
                fprintf(output, "\tmov\t%%eax, %%edx\n");
                break;
            case 2:
                fprintf(output, "\tmov\t%%eax, %%r8d\n");
                break;
            case 3:
                fprintf(output, "\tmov\t%%eax, %%r9d\n");
                break;
            default:
                fprintf(output, "\tmov\t%%eax, %d(%%rsp)\n",
                        32 + (i - 4) * 8);
                break;
            }
        }

        // 设置AL=0（没有向量参数）
        fprintf(output, "\txor\t%%al, %%al\n");

        fprintf(output, "\tcall\t%s\n", node->func_call.func_name);
        fprintf(output, "\taddq\t$%d, %%rsp\n", stack_space);
        break;
    }

    case AST_ARRAY_DECLARATION:
    {
        // 为数组分配48字节空间（12个整数）
        int array_size = 48;

        // 先分配栈空间
        fprintf(output, "\tsubq\t$%d, %%rsp\n", array_size);

        // 然后添加变量到符号表
        int var_offset = add_variable(node->array_decl.var_name);

        // 使用简单的循环初始化数组为0（避免SSE对齐问题）
        fprintf(output, "\tmovq\t$0, %%rax\n");
        fprintf(output, "\tmovq\t$6, %%rcx\n"); // 6次循环（48字节 / 8字节每次）
        fprintf(output, "\tleaq\t-%d(%%rbp), %%rdi\n", var_offset);
        fprintf(output, ".Linit_array_%d:\n", label_count);
        fprintf(output, "\tmovq\t%%rax, (%%rdi)\n");
        fprintf(output, "\taddq\t$8, %%rdi\n");
        fprintf(output, "\tloop\t.Linit_array_%d\n", label_count);
        label_count++;
        break;
    }

    case AST_ARRAY_ACCESS:
    {
        int var_offset = get_variable_offset(node->array_access.var_name);
        if (var_offset == -1)
        {
            fprintf(stderr, "Error: Undefined array '%s'\n", node->array_access.var_name);
            exit(1);
        }
        ast_generate_assembly(node->array_access.index, output);
        fprintf(output, "\tmovl\t%%eax, %%ecx\n");
        // 边界检查
        fprintf(output, "\tcmpl\t$0, %%ecx\n");
        fprintf(output, "\tjl\tarray_bounds_error\n");
        fprintf(output, "\tcmpl\t$11, %%ecx\n");
        fprintf(output, "\tjge\tarray_bounds_error\n");
        // 直接访问栈上的数组元素（数组从var_offset开始）
        fprintf(output, "\tmovl\t-%d(%%rbp,%%rcx,4), %%eax\n", var_offset);
        break;
    }

    case AST_ARRAY_ASSIGNMENT:
    {
        char *array_name = node->array_assignment.array_access->array_access.var_name;
        int var_offset = get_variable_offset(array_name);
        if (var_offset == -1)
        {
            fprintf(stderr, "Error: Undefined array '%s'\n", array_name);
            exit(1);
        }
        ast_generate_assembly(node->array_assignment.value, output);
        fprintf(output, "\tmovl\t%%eax, %%edx\n");
        ast_generate_assembly(node->array_assignment.array_access->array_access.index, output);
        fprintf(output, "\tmovl\t%%eax, %%ecx\n");
        // 边界检查
        fprintf(output, "\tcmpl\t$0, %%ecx\n");
        fprintf(output, "\tjl\tarray_bounds_error\n");
        fprintf(output, "\tcmpl\t$11, %%ecx\n");
        fprintf(output, "\tjge\tarray_bounds_error\n");
        // 直接赋值到栈上的数组元素（数组从var_offset开始）
        fprintf(output, "\tmovl\t%%edx, -%d(%%rbp,%%rcx,4)\n", var_offset);
        break;
    }

    case AST_BINARY_OP:
        ast_generate_assembly(node->binary.left, output);
        fprintf(output, "\tpushq\t%%rax\n");
        ast_generate_assembly(node->binary.right, output);
        fprintf(output, "\tmovl\t%%eax, %%ecx\n");
        fprintf(output, "\tpopq\t%%rdx\n");

        if (strcmp(node->binary.op, "+") == 0)
        {
            fprintf(output, "\taddl\t%%edx, %%eax\n");
        }
        else if (strcmp(node->binary.op, "-") == 0)
        {
            fprintf(output, "\tsubl\t%%edx, %%eax\n");
        }
        else if (strcmp(node->binary.op, "*") == 0)
        {
            fprintf(output, "\timull\t%%edx, %%eax\n");
        }
        else if (strcmp(node->binary.op, "/") == 0)
        {
            fprintf(output, "\tcltd\n");
            fprintf(output, "\tidivl\t%%ecx\n");
        }
        else if (strcmp(node->binary.op, "<") == 0)
        {
            fprintf(output, "\tcmpl\t%%ecx, %%edx\n");
            fprintf(output, "\tsetl\t%%al\n");
            fprintf(output, "\tmovzbl\t%%al, %%eax\n");
        }
        else if (strcmp(node->binary.op, "<=") == 0)
        {
            fprintf(output, "\tcmpl\t%%ecx, %%edx\n");
            fprintf(output, "\tsetle\t%%al\n");
            fprintf(output, "\tmovzbl\t%%al, %%eax\n");
        }
        else if (strcmp(node->binary.op, ">") == 0)
        {
            fprintf(output, "\tcmpl\t%%ecx, %%edx\n");
            fprintf(output, "\tsetg\t%%al\n");
            fprintf(output, "\tmovzbl\t%%al, %%eax\n");
        }
        else if (strcmp(node->binary.op, ">=") == 0)
        {
            fprintf(output, "\tcmpl\t%%ecx, %%edx\n");
            fprintf(output, "\tsetge\t%%al\n");
            fprintf(output, "\tmovzbl\t%%al, %%eax\n");
        }
        else if (strcmp(node->binary.op, "==") == 0)
        {
            fprintf(output, "\tcmpl\t%%ecx, %%edx\n");
            fprintf(output, "\tsete\t%%al\n");
            fprintf(output, "\tmovzbl\t%%al, %%eax\n");
        }
        else if (strcmp(node->binary.op, "!=") == 0)
        {
            fprintf(output, "\tcmpl\t%%ecx, %%edx\n");
            fprintf(output, "\tsetne\t%%al\n");
            fprintf(output, "\tmovzbl\t%%al, %%eax\n");
        }
        break;

    case AST_DECLARATION_INIT:
        ast_generate_assembly(node->decl.init_value, output);
        {
            int var_offset = add_variable(node->decl.var_name);
            fprintf(output, "\tmovl\t%%eax, -%d(%%rbp)\n", var_offset);
        }
        break;

    case AST_ASSIGNMENT:
        ast_generate_assembly(node->binary.right, output);
        {
            int var_offset = get_variable_offset(node->binary.left->string_value);
            if (var_offset == -1)
            {
                fprintf(stderr, "Error: Undefined variable '%s'\n", node->binary.left->string_value);
                exit(1);
            }
            fprintf(output, "\tmovl\t%%eax, -%d(%%rbp)\n", var_offset);
        }
        break;

    case AST_IF:
        ast_generate_assembly(node->if_stmt.cond, output);
        fprintf(output, "\ttestl\t%%eax, %%eax\n");
        fprintf(output, "\tje\t.Lelse%d\n", label_count);
        ast_generate_assembly(node->if_stmt.then_body, output);
        fprintf(output, "\tjmp\t.Lendif%d\n", label_count);
        fprintf(output, ".Lelse%d:\n", label_count);
        if (node->if_stmt.else_body)
        {
            ast_generate_assembly(node->if_stmt.else_body, output);
        }
        fprintf(output, ".Lendif%d:\n", label_count);
        label_count++;
        break;

    case AST_WHILE:
    {
        int saved_stack_offset = stack_offset;
        fprintf(output, ".Lwhile%d:\n", label_count);
        ast_generate_assembly(node->while_loop.cond, output);
        fprintf(output, "\ttestl\t%%eax, %%eax\n");
        fprintf(output, "\tjz\t.Lendwhile%d\n", label_count);
        ast_generate_assembly(node->while_loop.body, output);
        fprintf(output, "\tjmp\t.Lwhile%d\n", label_count);
        fprintf(output, ".Lendwhile%d:\n", label_count);
        stack_offset = saved_stack_offset;
        label_count++;
        break;
    }

    case AST_FOR:
    {
        int saved_stack_offset = stack_offset;
        ast_generate_assembly(node->for_loop.init, output);
        fprintf(output, ".Lfor%d:\n", label_count);
        ast_generate_assembly(node->for_loop.cond, output);
        fprintf(output, "\ttestl\t%%eax, %%eax\n");
        fprintf(output, "\tje\t.Lendfor%d\n", label_count);
        ast_generate_assembly(node->for_loop.body, output);
        ast_generate_assembly(node->for_loop.update, output);
        fprintf(output, "\tjmp\t.Lfor%d\n", label_count);
        fprintf(output, ".Lendfor%d:\n", label_count);
        stack_offset = saved_stack_offset;
        label_count++;
    }
    break;

    case AST_BLOCK:
        for (int i = 0; i < node->block.count; i++)
        {
            ast_generate_assembly(node->block.statements[i], output);
        }
        break;

    case AST_RETURN:
        if (node->binary.left)
        {
            ast_generate_assembly(node->binary.left, output);
        }
        fprintf(output, "\tmovl\t$0, %%eax\n");
        fprintf(output, "\taddq\t$48, %%rsp\n");
        fprintf(output, "\tpopq\t%%rbp\n");
        fprintf(output, "\tret\n");
        break;

    default:
        break;
    }
}